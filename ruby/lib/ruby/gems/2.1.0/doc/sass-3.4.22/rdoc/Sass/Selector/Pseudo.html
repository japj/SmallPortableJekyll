<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Sass::Selector::Pseudo - sass-3.4.22 Documentation</title>

<link href="../../fonts.css" rel="stylesheet">
<link href="../../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
</script>

<script src="../../js/jquery.js"></script>
<script src="../../js/navigation.js"></script>
<script src="../../js/search_index.js"></script>
<script src="../../js/search.js"></script>
<script src="../../js/searcher.js"></script>
<script src="../../js/darkfish.js"></script>


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">Simple
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-normalized_name">#normalized_name</a>
    
    <li ><a href="#method-i-specificity">#specificity</a>
    
    <li ><a href="#method-i-superselector-3F">#superselector?</a>
    
    <li ><a href="#method-i-to_s">#to_s</a>
    
    <li ><a href="#method-i-type">#type</a>
    
    <li class="calls-super" ><a href="#method-i-unify">#unify</a>
    
    <li ><a href="#method-i-with_selector">#with_selector</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Sass::Selector::Pseudo">
  <h1 id="class-Sass::Selector::Pseudo" class="class">
    class Sass::Selector::Pseudo
  </h1>

  <section class="description">
    
<p>A pseudoclass (e.g. `:visited`) or pseudoelement (e.g. `::first-line`)
selector. It can have arguments (e.g. `:nth-child(2n+1)`) which can contain
selectors (e.g. `:nth-child(2n+1 of .foo)`).</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="ACTUALLY_ELEMENTS">ACTUALLY_ELEMENTS
        
        <dd><p>Some pseudo-class-syntax selectors are actually considered pseudo-elements
and must be treated differently. This is a list of such selectors.</p>

<p>@return [Set&lt;String&gt;]</p>
        
      
      </dl>
    </section>
    

    
    <section class="attribute-method-details" class="method-section">
      <header>
        <h3>Attributes</h3>
      </header>

      
      <div id="attribute-i-arg" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">arg</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The argument to the selector, or `nil` if no argument was given.</p>

<p>@return [String, nil]</p>
        
        </div>
      </div>
      
      <div id="attribute-i-name" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">name</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The name of the selector.</p>

<p>@return [String]</p>
        
        </div>
      </div>
      
      <div id="attribute-i-selector" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">selector</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The selector argument, or `nil` if no selector exists.</p>

<p>If this and {#arg} are both set, {#arg} is considered a non-selector
prefix.</p>

<p>@return [CommaSequence]</p>
        
        </div>
      </div>
      
      <div id="attribute-i-syntactic_type" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">syntactic_type</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>Like {#type}, but returns the type of selector this looks like, rather than
the type it is semantically. This only differs from type for selectors in
{ACTUALLY_ELEMENTS}.</p>

<p>@return [Symbol]</p>
        
        </div>
      </div>
      
    </section>
    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(syntactic_type, name, arg, selector)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@param <a href="Pseudo.html#attribute-i-syntactic_type">#syntactic_type</a>
[Symbol] See {#syntactic_type} @param name [String] See {#name} @param arg
[nil, String] See {#arg} @param selector [nil, CommaSequence] See
{#selector}</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/sass/selector/pseudo.rb, line 44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">syntactic_type</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">arg</span>, <span class="ruby-identifier">selector</span>)
  <span class="ruby-ivar">@syntactic_type</span> = <span class="ruby-identifier">syntactic_type</span>
  <span class="ruby-ivar">@name</span> = <span class="ruby-identifier">name</span>
  <span class="ruby-ivar">@arg</span> = <span class="ruby-identifier">arg</span>
  <span class="ruby-ivar">@selector</span> = <span class="ruby-identifier">selector</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-normalized_name" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">normalized_name</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Like {#name}, but without any vendor prefix.</p>

<p>@return [String]</p>
          
          

          
          <div class="method-source-code" id="normalized_name-source">
            <pre><span class="ruby-comment"># File lib/sass/selector/pseudo.rb, line 111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">normalized_name</span>
  <span class="ruby-ivar">@normalized_name</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/^-[a-zA-Z0-9]+-/</span>, <span class="ruby-string">&#39;&#39;</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-specificity" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">specificity</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@see <a
href="AbstractSequence.html#method-i-specificity">Sass::Selector::AbstractSequence#specificity</a></p>
          
          

          
          <div class="method-source-code" id="specificity-source">
            <pre><span class="ruby-comment"># File lib/sass/selector/pseudo.rb, line 230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">specificity</span>
  <span class="ruby-keyword">return</span> <span class="ruby-value">1</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:element</span>
  <span class="ruby-keyword">return</span> <span class="ruby-constant">SPECIFICITY_BASE</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">selector</span>
  <span class="ruby-ivar">@specificity</span> <span class="ruby-operator">||=</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">normalized_name</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;not&#39;</span>
      <span class="ruby-identifier">min</span> = <span class="ruby-value">0</span>
      <span class="ruby-identifier">max</span> = <span class="ruby-value">0</span>
      <span class="ruby-identifier">selector</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">seq</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">spec</span> = <span class="ruby-identifier">seq</span>.<span class="ruby-identifier">specificity</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">spec</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Range</span>)
          <span class="ruby-identifier">min</span> = <span class="ruby-constant">Sass</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>.<span class="ruby-identifier">max</span>(<span class="ruby-identifier">spec</span>.<span class="ruby-identifier">begin</span>, <span class="ruby-identifier">min</span>)
          <span class="ruby-identifier">max</span> = <span class="ruby-constant">Sass</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>.<span class="ruby-identifier">max</span>(<span class="ruby-identifier">spec</span>.<span class="ruby-identifier">end</span>, <span class="ruby-identifier">max</span>)
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">min</span> = <span class="ruby-constant">Sass</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>.<span class="ruby-identifier">max</span>(<span class="ruby-identifier">spec</span>, <span class="ruby-identifier">min</span>)
          <span class="ruby-identifier">max</span> = <span class="ruby-constant">Sass</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>.<span class="ruby-identifier">max</span>(<span class="ruby-identifier">spec</span>, <span class="ruby-identifier">max</span>)
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">min</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">max</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">max</span> <span class="ruby-operator">:</span> (<span class="ruby-identifier">min</span><span class="ruby-operator">..</span><span class="ruby-identifier">max</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">min</span> = <span class="ruby-value">0</span>
      <span class="ruby-identifier">max</span> = <span class="ruby-value">0</span>
      <span class="ruby-identifier">selector</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">seq</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">spec</span> = <span class="ruby-identifier">seq</span>.<span class="ruby-identifier">specificity</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">spec</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Range</span>)
          <span class="ruby-identifier">min</span> = <span class="ruby-constant">Sass</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>.<span class="ruby-identifier">min</span>(<span class="ruby-identifier">spec</span>.<span class="ruby-identifier">begin</span>, <span class="ruby-identifier">min</span>)
          <span class="ruby-identifier">max</span> = <span class="ruby-constant">Sass</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>.<span class="ruby-identifier">max</span>(<span class="ruby-identifier">spec</span>.<span class="ruby-identifier">end</span>, <span class="ruby-identifier">max</span>)
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">min</span> = <span class="ruby-constant">Sass</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>.<span class="ruby-identifier">min</span>(<span class="ruby-identifier">spec</span>, <span class="ruby-identifier">min</span>)
          <span class="ruby-identifier">max</span> = <span class="ruby-constant">Sass</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>.<span class="ruby-identifier">max</span>(<span class="ruby-identifier">spec</span>, <span class="ruby-identifier">max</span>)
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">min</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">max</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">max</span> <span class="ruby-operator">:</span> (<span class="ruby-identifier">min</span><span class="ruby-operator">..</span><span class="ruby-identifier">max</span>)
    <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-superselector-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">superselector?</span><span
            class="method-args">(their_sseq, parents = [])</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns whether or not this selector matches all elements that the given
selector matches (as well as possibly more).</p>

<p>@example</p>

<pre class="ruby">(.<span class="ruby-identifier">foo</span>).<span class="ruby-identifier">superselector?</span>(.<span class="ruby-identifier">foo</span>.<span class="ruby-identifier">bar</span>) <span class="ruby-comment">#=&gt; true</span>
(.<span class="ruby-identifier">foo</span>).<span class="ruby-identifier">superselector?</span>(.<span class="ruby-identifier">bar</span>) <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>@param their_sseq [SimpleSequence] @param parents [Array&lt;SimpleSequence,
String&gt;] The parent selectors of `their_sseq`, if any. @return [Boolean]</p>
          
          

          
          <div class="method-source-code" id="superselector-3F-source">
            <pre><span class="ruby-comment"># File lib/sass/selector/pseudo.rb, line 149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">superselector?</span>(<span class="ruby-identifier">their_sseq</span>, <span class="ruby-identifier">parents</span> = [])
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">normalized_name</span>
  <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;matches&#39;</span>, <span class="ruby-string">&#39;any&#39;</span>
    <span class="ruby-comment"># :matches can be a superselector of another selector in one of two</span>
    <span class="ruby-comment"># ways. Either its constituent selectors can be a superset of those of</span>
    <span class="ruby-comment"># another :matches in the other selector, or any of its constituent</span>
    <span class="ruby-comment"># selectors can individually be a superselector of the other selector.</span>
    (<span class="ruby-identifier">their_sseq</span>.<span class="ruby-identifier">selector_pseudo_classes</span>[<span class="ruby-identifier">normalized_name</span>] <span class="ruby-operator">||</span> []).<span class="ruby-identifier">any?</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">their_sel</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Pseudo</span>)
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span>
      <span class="ruby-identifier">selector</span>.<span class="ruby-identifier">superselector?</span>(<span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">selector</span>)
    <span class="ruby-keyword">end</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">selector</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">any?</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">our_seq</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">their_seq</span> = <span class="ruby-constant">Sequence</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parents</span> <span class="ruby-operator">+</span> [<span class="ruby-identifier">their_sseq</span>])
      <span class="ruby-identifier">our_seq</span>.<span class="ruby-identifier">superselector?</span>(<span class="ruby-identifier">their_seq</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;has&#39;</span>, <span class="ruby-string">&#39;host&#39;</span>, <span class="ruby-string">&#39;host-context&#39;</span>
    <span class="ruby-comment"># Like :matches, :has (et al) can be a superselector of another</span>
    <span class="ruby-comment"># selector if its constituent selectors are a superset of those of</span>
    <span class="ruby-comment"># another :has in the other selector. However, the :matches other case</span>
    <span class="ruby-comment"># doesn&#39;t work, because :has refers to nested elements.</span>
    (<span class="ruby-identifier">their_sseq</span>.<span class="ruby-identifier">selector_pseudo_classes</span>[<span class="ruby-identifier">normalized_name</span>] <span class="ruby-operator">||</span> []).<span class="ruby-identifier">any?</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">their_sel</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Pseudo</span>)
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span>
      <span class="ruby-identifier">selector</span>.<span class="ruby-identifier">superselector?</span>(<span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">selector</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;not&#39;</span>
    <span class="ruby-identifier">selector</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">all?</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">our_seq</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">their_sseq</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">any?</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">their_sel</span><span class="ruby-operator">|</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Element</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Id</span>)
          <span class="ruby-comment"># `:not(a)` is a superselector of `h1` and `:not(#foo)` is a</span>
          <span class="ruby-comment"># superselector of `#bar`.</span>
          <span class="ruby-identifier">our_sseq</span> = <span class="ruby-identifier">our_seq</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">last</span>
          <span class="ruby-keyword">next</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">our_sseq</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">SimpleSequence</span>)
          <span class="ruby-identifier">our_sseq</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">any?</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">our_sel</span><span class="ruby-operator">|</span>
            <span class="ruby-identifier">our_sel</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">our_sel</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">their_sel</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">next</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Pseudo</span>)
          <span class="ruby-keyword">next</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span>
          <span class="ruby-comment"># :not(X) is a superselector of :not(Y) exactly when Y is a</span>
          <span class="ruby-comment"># superselector of X.</span>
          <span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">selector</span>.<span class="ruby-identifier">superselector?</span>(<span class="ruby-constant">CommaSequence</span>.<span class="ruby-identifier">new</span>([<span class="ruby-identifier">our_seq</span>]))
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;current&#39;</span>
    (<span class="ruby-identifier">their_sseq</span>.<span class="ruby-identifier">selector_pseudo_classes</span>[<span class="ruby-string">&#39;current&#39;</span>] <span class="ruby-operator">||</span> []).<span class="ruby-identifier">any?</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">their_current</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">their_current</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">name</span>
      <span class="ruby-comment"># Explicitly don&#39;t check for nested superselector relationships</span>
      <span class="ruby-comment"># here. :current(.foo) isn&#39;t always a superselector of</span>
      <span class="ruby-comment"># :current(.foo.bar), since it matches the *innermost* ancestor of</span>
      <span class="ruby-comment"># the current element that matches the selector. For example:</span>
      <span class="ruby-comment">#</span>
      <span class="ruby-comment">#     &lt;div class=&quot;foo bar&quot;&gt;</span>
      <span class="ruby-comment">#       &lt;p class=&quot;foo&quot;&gt;</span>
      <span class="ruby-comment">#         &lt;span&gt;current element&lt;/span&gt;</span>
      <span class="ruby-comment">#       &lt;/p&gt;</span>
      <span class="ruby-comment">#     &lt;/div&gt;</span>
      <span class="ruby-comment">#</span>
      <span class="ruby-comment"># Here :current(.foo) would match the p element and *not* the div</span>
      <span class="ruby-comment"># element, whereas :current(.foo.bar) would match the div and not</span>
      <span class="ruby-comment"># the p.</span>
      <span class="ruby-identifier">selector</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">their_current</span>.<span class="ruby-identifier">selector</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;nth-child&#39;</span>, <span class="ruby-string">&#39;nth-last-child&#39;</span>
    <span class="ruby-identifier">their_sseq</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">any?</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">their_sel</span><span class="ruby-operator">|</span>
      <span class="ruby-comment"># This misses a few edge cases. For example, `:nth-child(n of X)`</span>
      <span class="ruby-comment"># is a superselector of `X`, and `:nth-child(2n of X)` is a</span>
      <span class="ruby-comment"># superselector of `:nth-child(4n of X)`. These seem rare enough</span>
      <span class="ruby-comment"># not to be worth worrying about, though.</span>
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Pseudo</span>)
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span>
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">arg</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">arg</span>
      <span class="ruby-identifier">selector</span>.<span class="ruby-identifier">superselector?</span>(<span class="ruby-identifier">their_sel</span>.<span class="ruby-identifier">selector</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">throw</span> <span class="ruby-node">&quot;[BUG] Unknown selector pseudo class #{name}&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_s" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_s</span><span
            class="method-args">(opts = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@see Selector#to_s</p>
          
          

          
          <div class="method-source-code" id="to_s-source">
            <pre><span class="ruby-comment"># File lib/sass/selector/pseudo.rb, line 116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_s</span>(<span class="ruby-identifier">opts</span> = {})
  <span class="ruby-identifier">res</span> = (<span class="ruby-identifier">syntactic_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:class</span> <span class="ruby-operator">?</span> <span class="ruby-string">&quot;:&quot;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&quot;::&quot;</span>) <span class="ruby-operator">+</span> <span class="ruby-ivar">@name</span>
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@arg</span> <span class="ruby-operator">||</span> <span class="ruby-ivar">@selector</span>
    <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;(&quot;</span>
    <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-ivar">@arg</span>.<span class="ruby-identifier">strip</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@arg</span>
    <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@arg</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-ivar">@selector</span>
    <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-ivar">@selector</span>.<span class="ruby-identifier">to_s</span>(<span class="ruby-identifier">opts</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@selector</span>
    <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;)&quot;</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">res</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-type" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">type</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The type of the selector. `:class` if this is a pseudoclass selector,
`:element` if it&#39;s a pseudoelement.</p>

<p>@return [Symbol]</p>
          
          

          
          <div class="method-source-code" id="type-source">
            <pre><span class="ruby-comment"># File lib/sass/selector/pseudo.rb, line 104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">type</span>
  <span class="ruby-constant">ACTUALLY_ELEMENTS</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">normalized_name</span>) <span class="ruby-operator">?</span> <span class="ruby-value">:element</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">syntactic_type</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-unify" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">unify</span><span
            class="method-args">(sels)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns `nil` if this is a pseudoelement selector and `sels` contains a
pseudoelement selector different than this one.</p>

<p>@see <a
href="SimpleSequence.html#method-i-unify">Sass::Selector::SimpleSequence#unify</a></p>
          
          
            <div class="method-calls-super">
              Calls superclass method
              
            </div>
          

          
          <div class="method-source-code" id="unify-source">
            <pre><span class="ruby-comment"># File lib/sass/selector/pseudo.rb, line 132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">unify</span>(<span class="ruby-identifier">sels</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:element</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">sels</span>.<span class="ruby-identifier">any?</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sel</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Pseudo</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:element</span> <span class="ruby-operator">&amp;&amp;</span>
      (<span class="ruby-identifier">sel</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">arg</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">arg</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">selector</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">selector</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">super</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-with_selector" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">with_selector</span><span
            class="method-args">(new_selector)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a copy of this with {#selector} set to {#new_selector}.</p>

<p>@param new_selector [CommaSequence] @return [Array&lt;Simple&gt;]</p>
          
          

          
          <div class="method-source-code" id="with_selector-source">
            <pre><span class="ruby-comment"># File lib/sass/selector/pseudo.rb, line 55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">with_selector</span>(<span class="ruby-identifier">new_selector</span>)
  <span class="ruby-identifier">result</span> = <span class="ruby-constant">Pseudo</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">syntactic_type</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">arg</span>,
    <span class="ruby-constant">CommaSequence</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">new_selector</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">seq</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">next</span> <span class="ruby-identifier">seq</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">seq</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">sseq</span> = <span class="ruby-identifier">seq</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">first</span>
      <span class="ruby-keyword">next</span> <span class="ruby-identifier">seq</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">sseq</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">SimpleSequence</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">sseq</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">sel</span> = <span class="ruby-identifier">sseq</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">first</span>
      <span class="ruby-keyword">next</span> <span class="ruby-identifier">seq</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Pseudo</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">selector</span>

      <span class="ruby-keyword">case</span> <span class="ruby-identifier">normalized_name</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;not&#39;</span>
        <span class="ruby-comment"># In theory, if there&#39;s a nested :not its contents should be</span>
        <span class="ruby-comment"># unified with the return value. For example, if :not(.foo)</span>
        <span class="ruby-comment"># extends .bar, :not(.bar) should become .foo:not(.bar). However,</span>
        <span class="ruby-comment"># this is a narrow edge case and supporting it properly would make</span>
        <span class="ruby-comment"># this code and the code calling it a lot more complicated, so</span>
        <span class="ruby-comment"># it&#39;s not supported for now.</span>
        <span class="ruby-keyword">next</span> [] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">normalized_name</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;matches&#39;</span>
        <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">selector</span>.<span class="ruby-identifier">members</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;matches&#39;</span>, <span class="ruby-string">&#39;any&#39;</span>, <span class="ruby-string">&#39;current&#39;</span>, <span class="ruby-string">&#39;nth-child&#39;</span>, <span class="ruby-string">&#39;nth-last-child&#39;</span>
        <span class="ruby-comment"># As above, we could theoretically support :not within :matches, but</span>
        <span class="ruby-comment"># doing so would require this method and its callers to handle much</span>
        <span class="ruby-comment"># more complex cases that likely aren&#39;t worth the pain.</span>
        <span class="ruby-keyword">next</span> [] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">arg</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">arg</span>
        <span class="ruby-identifier">sel</span>.<span class="ruby-identifier">selector</span>.<span class="ruby-identifier">members</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;has&#39;</span>, <span class="ruby-string">&#39;host&#39;</span>, <span class="ruby-string">&#39;host-context&#39;</span>
        <span class="ruby-comment"># We can&#39;t expand nested selectors here, because each layer adds an</span>
        <span class="ruby-comment"># additional layer of semantics. For example, `:has(:has(img))`</span>
        <span class="ruby-comment"># doesn&#39;t match `&lt;div&gt;&lt;img&gt;&lt;/div&gt;` but `:has(img)` does.</span>
        <span class="ruby-identifier">sel</span>
      <span class="ruby-keyword">else</span>
        []
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>.<span class="ruby-identifier">flatten</span>))

  <span class="ruby-comment"># Older browsers support :not but only with a single complex selector.</span>
  <span class="ruby-comment"># In order to support those browsers, we break up the contents of a :not</span>
  <span class="ruby-comment"># unless it originally contained a selector list.</span>
  <span class="ruby-keyword">return</span> [<span class="ruby-identifier">result</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">normalized_name</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;not&#39;</span>
  <span class="ruby-keyword">return</span> [<span class="ruby-identifier">result</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">selector</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">result</span>.<span class="ruby-identifier">selector</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">seq</span><span class="ruby-operator">|</span>
    <span class="ruby-constant">Pseudo</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">syntactic_type</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">arg</span>, <span class="ruby-constant">CommaSequence</span>.<span class="ruby-identifier">new</span>([<span class="ruby-identifier">seq</span>]))
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

